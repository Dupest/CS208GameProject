Index: src/GameLogic.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import javafx.geometry.Point2D;\r\n\r\nimport java.awt.event.KeyEvent;\r\nimport java.awt.event.KeyListener;\r\nimport java.util.HashMap;\r\nimport java.util.Random;\r\n\r\n/*\r\n * To change this license header, choose License Headers in Project Properties.\r\n * To change this template file, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\n\r\n/**\r\n *  By Svetozar Draganitchki\r\n * \r\n */\r\npublic class GameLogic implements KeyListener{\r\n    //TODO: Figure out rehashing - how do we actually do it, is it an automatic call?\r\n    //private Room[][] mapLayout;                                          //TODO: Change to 2D array potentially.\r\n\r\n    private HashMap<Point2D, Room> roomList;\r\n    private Key key;\r\n    private HashMap<Integer, Player> playerList;\r\n    private int maxPlayers;\r\n    private int gridRows;\r\n    private int gridColumns;\r\n    private static final int trapChance = 10;\r\n\r\n    \r\n    public GameLogic(){\r\n        roomList = new HashMap<>();\r\n        playerList = new HashMap<>();\r\n        mapInitializing(-1, -1);\r\n        maxPlayers = 4;\r\n        gridColumns = 9;\r\n        gridRows = 9;\r\n    }\r\n\r\n    public GameLogic(int maxPlayers) {\r\n        roomList = new HashMap<>();\r\n        playerList = new HashMap<Integer, Player> ();\r\n        mapInitializing(-1, -1);\r\n        this.maxPlayers = maxPlayers;\r\n        gridColumns = 9;\r\n        gridRows = 9;\r\n    }\r\n    public GameLogic(int maxPlayers, int gridColumns, int gridRows) {\r\n        key = null;\r\n        playerList = new HashMap<Integer, Player> ();\r\n        roomList = new HashMap<>();\r\n        mapInitializing(-1, -1);\r\n        this.maxPlayers = maxPlayers;\r\n        this.gridColumns = gridColumns;\r\n        this.gridRows = gridRows;\r\n    }\r\n\r\n    public GameLogic(Room[][] mapLayout, Key key, HashMap<Integer, Player> playerList){\r\n        playerList = new HashMap<Integer, Player> ();\r\n        roomList = new HashMap<>();\r\n        this.key = key;\r\n        this.playerList = playerList;\r\n        mapInitializing(-1, -1);\r\n    }\r\n\r\n\r\n    /**\r\n     * method allows there to be a set amount of both\r\n     * players and trapped rooms at the initialization of the\r\n     * game when both parameters are -1\r\n     * otherwise both the number of players and trapped rooms may be changed\r\n     * or only one may be changed-Justin Lamberson\r\n     */\r\n    public void mapInitializing(int players, int trappedRooms){\r\n        //method assumes the map generated is a 9 x 9\r\n        Random rand = new Random();\r\n\r\n        int roomNumber = 1;\r\n\r\n        //traps is max number of traps\r\n        int traps;\r\n        if(trappedRooms >= -1){\r\n            traps = trappedRooms;\r\n        } else {\r\n            traps = 10;\r\n        }\r\n\r\n        //loop initializes all rooms\r\n//        for(int i = 0; i < 81; i++){\r\n//            if(rand.nextInt(101) < 50 || traps >= 0){\r\n//                traps--;\r\n//                mapLayout.put(roomNumber, new Room(false, roomNumber, true, new Key(mapLayout.get(i) ,1) ));\r\n//                roomNumber++;\r\n//            }else if(roomNumber == 81){\r\n//                mapLayout.put(roomNumber, new Room(true, roomNumber, false, new Key(mapLayout.get(i) ,1) ));\r\n//            } else {\r\n//                mapLayout.put(roomNumber, new Room(false, roomNumber, false, new Key(mapLayout.get(i) ,1) ));\r\n//                roomNumber++;\r\n//            }\r\n//        }\r\n        //loop initializes all rooms\r\n        for(int y = 0 ; y < 9; y ++)\r\n        {\r\n            for(int x = 0 ; x < 9; x ++)\r\n            {\r\n                if(rand.nextInt(100) <= trapChance && traps >= 0){\r\n                    roomList.put(new Point2D(x, y), new Room(false, roomNumber, true, x, y));\r\n                    traps --;\r\n                    roomNumber++;\r\n                } else if (x == 8 && y == 8){\r\n                    roomList.put(new Point2D(x, y), new Room(true, roomNumber, false, x, y));\r\n                    roomNumber++;\r\n                }\r\n                else\r\n                {\r\n                    roomList.put(new Point2D(x, y), new Room(true, roomNumber, false, x, y));\r\n                    roomNumber++;\r\n                }\r\n            }\r\n        }\r\n\r\n        int x = rand.nextInt(8);\r\n        int y = rand.nextInt(7);\r\n\r\n        //generates final key =\r\n        key = new Key(roomList.get(new Point2D(8,8)), 1, x, y);\r\n\r\n\r\n\r\n\r\n        //generates the number of players specified by the variable players\r\n        //generates the players at the top right of the map\r\n        if(players == -1){\r\n            for(int i = 0; i < 4; i++){\r\n                playerList.put(i+1, new Player(0 ,0));\r\n            }\r\n        }\r\n        else{\r\n            for(int i = 0; i < players; i++){\r\n                playerList.put(i+1, new Player(0 ,0));\r\n            }\r\n        }\r\n\r\n    }\r\n    /*\r\n        By Svetozar Draganitchki\r\n        method that checks if player can enter room\r\n    */\r\n    public boolean canEnter(int roomX, int roomY,Player p){\r\n        if((roomList.get(new Point2D(roomX, roomY)).isLocked())){\r\n            return hasKey(roomX, roomY, p);           //Simplified this logic - DO\r\n        }\r\n        return true;\r\n    }\r\n\r\n    public void playerMoves(Player player){\r\n    }\r\n    \r\n    /*\r\n        By Svetozar Draganitchki\r\n        checks if a player has the matching key to a room\r\n    */\r\n    public boolean hasKey(int roomX, int roomY, Player p){\r\n        if((roomList.get(new Point2D(roomX, roomY)).getDoorID() == p.getKey().getMyRoom().getDoorID())){\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * checks that a player has not gone out of bounds\r\n     * @param p is the player referenced\r\n     */\r\n    public void EnteredRoom(Player p){\r\n        int x = p.getX();\r\n        int y = p.getY();\r\n        if(x < 0){\r\n            p.setX(0);\r\n        } else if (x > gridColumns){\r\n            p.setX(gridColumns);\r\n        }\r\n\r\n        if(y < 0){\r\n            p.setY(0);\r\n        } else if(y > gridRows){\r\n            p.setY(gridRows);\r\n        }\r\n    }\r\n    \r\n    public Player getPlayer(int playerID){\r\n        return playerList.get(playerID);\r\n    }\r\n    \r\n    public Key getKey(){\r\n        return key;\r\n    }\r\n    \r\n    public Room getRoom(int x, int y){\r\n        return (roomList.get(new Point2D(x, y)));\r\n    }\r\n    \r\n    @Override\r\n    public void keyTyped(KeyEvent e) {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void keyPressed(KeyEvent e) {\r\n        if (e.getKeyCode() == KeyEvent.VK_RIGHT ||\r\n            e.getKeyCode() == KeyEvent.VK_D) {\r\n            System.out.println(\"Right key Released\");\r\n            \r\n        }\r\n        if (e.getKeyCode() == KeyEvent.VK_LEFT ||\r\n            e.getKeyCode() == KeyEvent.VK_A) {\r\n            System.out.println(\"Left key Released\");\r\n            \r\n        }\r\n        if (e.getKeyCode() == KeyEvent.VK_KP_UP ||\r\n            e.getKeyCode() == KeyEvent.VK_W) {\r\n            System.out.println(\"Up key pressed\");\r\n            \r\n        }\r\n        if (e.getKeyCode() == KeyEvent.VK_KP_DOWN ||\r\n            e.getKeyCode() == KeyEvent.VK_S) {\r\n            System.out.println(\"Down key pressed\");\r\n            \r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void keyReleased(KeyEvent e) {\r\n        if (e.getKeyCode() == KeyEvent.VK_RIGHT ||\r\n            e.getKeyCode() == KeyEvent.VK_D) {\r\n            System.out.println(\"Right key Released\");\r\n            \r\n        }\r\n        if (e.getKeyCode() == KeyEvent.VK_LEFT ||\r\n            e.getKeyCode() == KeyEvent.VK_A) {\r\n            System.out.println(\"Left key Released\");\r\n            \r\n        }\r\n        if (e.getKeyCode() == KeyEvent.VK_KP_UP ||\r\n            e.getKeyCode() == KeyEvent.VK_W) {\r\n            System.out.println(\"Up key pressed\");\r\n            \r\n        }\r\n        if (e.getKeyCode() == KeyEvent.VK_KP_DOWN ||\r\n            e.getKeyCode() == KeyEvent.VK_S) {\r\n            System.out.println(\"Down key pressed\");\r\n            \r\n        }\r\n    }\r\n\r\n    public HashMap<Point2D, Room> getRoomList() {\r\n        return roomList;\r\n    }\r\n\r\n    public void setRoomList(HashMap<Point2D, Room> roomList) {\r\n        this.roomList = roomList;\r\n    }\r\n\r\n    public void setKey(Key newKey){\r\n        key = newKey;\r\n    }\r\n\r\n\r\n    public HashMap<Integer, Player> getPlayerList() {\r\n        return playerList;\r\n    }\r\n\r\n    public void setPlayerList(HashMap<Integer, Player> playerList) {\r\n        this.playerList = playerList;\r\n    }\r\n\r\n    public int getMaxPlayers() {\r\n        return maxPlayers;\r\n    }\r\n\r\n    public void setMaxPlayers(int maxPlayers) {\r\n        this.maxPlayers = maxPlayers;\r\n    }\r\n\r\n    public static int getTrapChance() {\r\n        return trapChance;\r\n    }\r\n\r\n    public int getGridRows() {\r\n        return gridRows;\r\n    }\r\n\r\n    public void setGridRows(int gridRows) {\r\n        this.gridRows = gridRows;\r\n    }\r\n\r\n    public int getGridColumns() {\r\n        return gridColumns;\r\n    }\r\n\r\n    public void setGridColumns(int gridColumns) {\r\n        this.gridColumns = gridColumns;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/GameLogic.java b/src/GameLogic.java
--- a/src/GameLogic.java	(revision 7a557609cb1924575ee046b6dcb6d5aaaaa6b2bf)
+++ b/src/GameLogic.java	(date 1607997256968)
@@ -45,6 +45,7 @@
         gridColumns = 9;
         gridRows = 9;
     }
+
     public GameLogic(int maxPlayers, int gridColumns, int gridRows) {
         key = null;
         playerList = new HashMap<Integer, Player> ();
@@ -55,6 +56,7 @@
         this.gridRows = gridRows;
     }
 
+
     public GameLogic(Room[][] mapLayout, Key key, HashMap<Integer, Player> playerList){
         playerList = new HashMap<Integer, Player> ();
         roomList = new HashMap<>();
@@ -156,7 +158,7 @@
     public void playerMoves(Player player){
     }
     
-    /*
+    /**
         By Svetozar Draganitchki
         checks if a player has the matching key to a room
     */
@@ -195,7 +197,7 @@
     public Key getKey(){
         return key;
     }
-    
+
     public Room getRoom(int x, int y){
         return (roomList.get(new Point2D(x, y)));
     }
Index: src/Tester.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>\r\n\r\nimport javafx.application.Application;\r\nimport javafx.fxml.FXMLLoader;\r\nimport javafx.scene.Scene;\r\n\r\nimport javafx.scene.layout.VBox;\r\nimport javafx.stage.Stage;\r\n\r\nimport java.io.IOException;\r\n\r\npublic class Tester extends Application {\r\n\r\n    public static void main(String[] args) {\r\n        launch(args);\r\n    }\r\n\r\n    @Override\r\n    public void start(Stage primaryStage) throws IOException {\r\n        FXMLLoader loader = new FXMLLoader(getClass().getResource(\"GameProjectFXML.fxml\"));\r\n        Scene newScene = new Scene((VBox)loader.load());\r\n        primaryStage.setScene(newScene);\r\n        primaryStage.setTitle(\"CastleDelver\");\r\n        primaryStage.setHeight(900);\r\n        primaryStage.setWidth(1600);\r\n        primaryStage.show();\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Tester.java b/src/Tester.java
--- a/src/Tester.java	(revision 7a557609cb1924575ee046b6dcb6d5aaaaa6b2bf)
+++ b/src/Tester.java	(date 1607997864337)
@@ -24,5 +24,7 @@
         primaryStage.setHeight(900);
         primaryStage.setWidth(1600);
         primaryStage.show();
+
+
     }
 }
\ No newline at end of file
Index: src/MainGameController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import javafx.animation.Animation;\r\nimport javafx.animation.KeyFrame;\r\nimport javafx.animation.Timeline;\r\nimport javafx.fxml.FXML;\r\nimport javafx.geometry.Pos;\r\nimport javafx.scene.Group;\r\nimport javafx.scene.Node;\r\nimport javafx.scene.canvas.Canvas;\r\nimport javafx.scene.canvas.GraphicsContext;\r\nimport javafx.scene.control.Label;\r\nimport javafx.scene.input.MouseEvent;\r\nimport javafx.scene.layout.*;\r\nimport javafx.scene.paint.Color;\r\nimport javafx.scene.shape.Rectangle;\r\n\r\nimport java.text.DateFormat;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.*;\r\nimport javafx.scene.shape.Circle;\r\nimport javafx.util.Duration;\r\n\r\n//Edited By Svetozar Draganitchki\r\npublic class MainGameController {\r\n\r\n    //We keep track of the canvases and gridPane node refs since they're made dynamically\r\n    private Node[][] gridPaneNodes;\r\n    private Node[][] canvases;\r\n    private GameLogic gameLogic;\r\n\r\n    //References to our main window objects for easier coding/listeners yada-yada\r\n    @FXML\r\n    private VBox rootPane;\r\n\r\n    @FXML\r\n    private GridPane mainGridPane;\r\n\r\n    @FXML\r\n    private HBox buttonPane;\r\n\r\n    @FXML\r\n    private Label timerLabel;\r\n\r\n\r\n    private Room[][]  mapLayout;\r\n    private HashMap<Integer, Key> keyMap;\r\n    private HashMap<Integer, Player> playerMap;\r\n\r\n\r\n    private double individualGridPaneWidth;\r\n    private double individualGridPaneHeight;\r\n    private final Color[] playerColors = {Color.VIOLET, Color.ORANGE, Color.RED, Color.BLACK};\r\n\r\n    private static final int PADDING = 2;\r\n\r\n    /**\r\n     * This runs first whenever application tester calls Loader.load() so it acts as the driver code for our JavaFX project\r\n     */\r\n    public void initialize() {\r\n\r\n        //We can get them number of columns/rows by checking to see how many constraints there are. There will be a specific constraint object for each row/column\r\n        gameLogic = new GameLogic(4);\r\n        int numColumns = mainGridPane.getColumnConstraints().size();\r\n        int numRows  = mainGridPane.getRowConstraints().size();\r\n        //setGridPaneUp();\r\n        //Init arrays\r\n        gridPaneNodes = new Node[numRows][numColumns];\r\n        canvases = new Node[numRows][numColumns];\r\n        mapLayout = new Room[numRows][numColumns];\r\n        populateArray();\r\n\r\n        //We bind a listener to the size of the window to allow things to resize smoothly. resizing calls doStuff()\r\n        mainGridPane.heightProperty().addListener(evt -> doStuff());\r\n        mainGridPane.widthProperty().addListener(evt -> doStuff());\r\n\r\n        //Creates the \"map\" of rooms, players, and Keys\r\n        keyMap = new HashMap<>();\r\n        playerMap = new HashMap<>();\r\n\r\n        mapInitializing();\r\n        long endTime = 60;\r\n        Label timeLabel = new Label();\r\n        DateFormat timeFormat = new SimpleDateFormat( \"HH:mm:ss\" );\r\n        final Timeline timeline = new Timeline(\r\n                new KeyFrame(\r\n                        Duration.millis( 500 ),\r\n                        event -> {\r\n                            final long diff = endTime - System.currentTimeMillis();\r\n                            if ( diff < 0 ) {\r\n                                //  timeLabel.setText( \"00:00:00\" );\r\n                                timeLabel.setText( timeFormat.format( 0 ) );\r\n                            } else {\r\n                                timeLabel.setText( timeFormat.format( diff ) );\r\n                            }\r\n                        }\r\n                )\r\n        );\r\n        timeline.setCycleCount( Animation.INDEFINITE );\r\n        timeline.play();\r\n    }\r\n    /*\r\n    initializes the map depending on the size of the map and\r\n    number of players. By default, it generates a 9 x 9 map\r\n    and 2 players (Justin Lamberson)\r\n     */\r\n    public void mapInitializing(){\r\n        int numColumns = gameLogic.getGridColumns();\r\n        int numRows  = gameLogic.getGridRows();\r\n        System.out.println(numColumns + \" \" + numRows);\r\n        //assumes that there are 2 players and a 9 x 9 map\r\n        Random rand = new Random();\r\n\r\n        //traps is max number of traps\r\n        int traps = 10;\r\n        int roomNumber = 1;\r\n\r\n        //loop initializes all rooms\r\n        for(int i = 0; i < numRows; i++){\r\n            for(int k = 0; k < numColumns; k++){\r\n                if(rand.nextInt(101) < 50 || traps >= 0){\r\n                    traps--;\r\n                    mapLayout[i][k] = new Room(false, roomNumber, true);\r\n\r\n                //If last room ie (8,8)\r\n                }else if(i == numRows-1 && k == numColumns-1){\r\n\r\n                    //Make special constructor for the final room so this is different from else loop\r\n                    mapLayout[i][k] = new Room(true, roomNumber, false);\r\n                } else {\r\n                    mapLayout[i][k] = new Room(false, roomNumber, false);\r\n                }\r\n                roomNumber++;\r\n            }\r\n        }\r\n        System.out.println(roomNumber);\r\n        //generates final key =\r\n        //keyList.put(81, new Key(mapLayout[8][8] ,1));\r\n\r\n        //generates the two players in the top 2 rooms\r\n        playerMap.put(1, new Player(mapLayout[0][0]));\r\n        playerMap.put(2, new Player(mapLayout[0][1]));\r\n\r\n    }\r\n\r\n    private void setGridPaneUp(){\r\n        for (int i = 0 ; i < gameLogic.getGridRows(); i++) {\r\n            RowConstraints row = new RowConstraints();\r\n            row.setVgrow(Priority.ALWAYS);\r\n            mainGridPane.getRowConstraints().add(row);\r\n        }\r\n\r\n        for (int j = 0 ; j < gameLogic.getGridColumns(); j++) {\r\n            ColumnConstraints col = new ColumnConstraints();\r\n            col.setHgrow(Priority.ALWAYS);\r\n            mainGridPane.getColumnConstraints().add(col);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Draw things\r\n     */\r\n    private void doStuff(){\r\n        int numColumns = gameLogic.getGridColumns();\r\n        int numRows  = gameLogic.getGridRows();\r\n        //First call to doStuff() will be in the initialize() method and for do to order of the loader's ops, getHeight() and getWidth() will return 0 at this point.\r\n        // So we call the prefHeight/Width in that case.\r\n        double winHeight = mainGridPane.getHeight();\r\n        double winWidth = mainGridPane.getWidth();\r\n        System.out.println(winWidth/numRows + \" \" + mainGridPane.getColumnConstraints().get(1).toString());\r\n        if(winHeight == 0 || winWidth == 0){\r\n            winHeight = mainGridPane.getPrefHeight();\r\n            winWidth = mainGridPane.getPrefWidth();\r\n        }\r\n        individualGridPaneWidth = (winWidth/numColumns);\r\n        individualGridPaneHeight = (winHeight/numRows);\r\n        //Another hacky solution that I've found. getChildren().clear() removes the gridlines on our gridpane. However, this information is stored within the very first\r\n        //child so we simply store that through the deletion, and fit it back in to regain our lines.\r\n        Node node = mainGridPane.getChildren().get(0);\r\n        mainGridPane.getChildren().clear();\r\n        mainGridPane.getChildren().add(0, node);\r\n        GraphicsContext gc;\r\n        Canvas newMapImage = null;\r\n        //For each node within the gridpane draw a circle representing a room.\r\n        for(int i = 0; i < numRows; i++){\r\n            for(int k = 0; k < numColumns; k++){\r\n\r\n                //Think there's a better way to do this, but default behavior each gridpane node gets a percent of the screen X based on number of children C (size = X/C)\r\n                newMapImage = new Canvas(winWidth/numColumns, winHeight/numRows);\r\n                canvases[i][k] = newMapImage;\r\n\r\n                //Returns a graphics object of the canvas for drawing\r\n                gc = newMapImage.getGraphicsContext2D();\r\n                Rectangle newRect = new Rectangle\r\n                        (newMapImage.getWidth()/2.0, newMapImage.getHeight()/2.0, newMapImage.getWidth()-PADDING, newMapImage.getHeight()-PADDING);\r\n                mapLayout[i][k].setRoomRender(newRect);\r\n                drawRectangle(gc, newRect);\r\n                Group newGroup = new Group();\r\n                newGroup.getChildren().add(newMapImage);\r\n                mainGridPane.add(newGroup, i, k);\r\n                \r\n            }\r\n        }\r\n        //Way to draw traps\r\n        for(int i = 0; i < numRows; i++){\r\n            for(int j = 0; j < numColumns; j++) {\r\n                if (gameLogic.getRoom(i, j).isATrap()) {\r\n                    Room currRoom = gameLogic.getRoom(i, j);\r\n                    //mainGridPane.add(drawTrap(new Rectangle(currRoom.getRoomRender().getX(), currRoom.getRoomRender().getY())), currRoom.getX(), currRoom.getY());\r\n                }\r\n            }\r\n        }\r\n\r\n        //To keep track of when to jump down on the y offset.\r\n        int[] xYOffsets = {0, 0};\r\n\r\n        //Approximate width/height of each individual rectangle\r\n        //double individualGridPaneWidth = (winWidth/numColumns);\r\n       // double individualGridPaneHeight = (winHeight/numRows);\r\n\r\n        //Take the lesser of the two values ( should usually be the height, but..) and sets the radius to half that value (accounting for padding)\r\n        double radius = Math.min(individualGridPaneHeight/gameLogic.getMaxPlayers(), individualGridPaneWidth/gameLogic.getMaxPlayers())-(PADDING/2.0);\r\n\r\n        //TODO: Check if FlowPane offers an easier implementation.\r\n        GridPane startingPlayers = new GridPane();\r\n\r\n        startingPlayers.setAlignment(Pos.CENTER);\r\n        startingPlayers.setHgap(individualGridPaneHeight/gameLogic.getMaxPlayers());\r\n        startingPlayers.setVgap(PADDING);\r\n        for(int i = 0; i < gameLogic.getMaxPlayers(); i++) {\r\n            startingPlayers.add(new Circle(radius, playerColors[i%4]), xYOffsets[0], xYOffsets[1]);\r\n            xYOffsets[0]++;\r\n            if( i == gameLogic.getMaxPlayers()/2-1){\r\n               xYOffsets[0] = 0;\r\n               xYOffsets[1]++;\r\n            }\r\n        }\r\n        mainGridPane.add(startingPlayers, 0,0);\r\n        //movePlayer(null);\r\n        mainGridPane.add(drawKey(new Rectangle()), 7, 7);\r\n        //movePlayer(null);\r\n        \r\n        //Groups just add an extra layer of organization. In this case not necessary, but trying to show of some of the syntax too\r\n\r\n    }\r\n\r\n    private void populateArray(){\r\n        for (Node child : mainGridPane.getChildren()) {\r\n            Integer column = GridPane.getColumnIndex(child);\r\n            Integer row = GridPane.getRowIndex(child);\r\n            if (column != null && row != null) {\r\n                gridPaneNodes[column][row] = child;\r\n            }\r\n        }\r\n        int numColumns = mainGridPane.getColumnConstraints().size();\r\n        int numRows  = mainGridPane.getRowConstraints().size();\r\n        double winHeight = mainGridPane.getHeight();\r\n        double winWidth = mainGridPane.getWidth();\r\n        if(winHeight == 0 || winWidth == 0){\r\n            winHeight = mainGridPane.getPrefHeight();\r\n            winWidth = mainGridPane.getPrefWidth();\r\n        }\r\n        for(int i = 0; i < canvases.length; i++){\r\n            for(int k = 0; k < canvases[0].length; k++){\r\n                canvases[i][k] = new Canvas(winWidth/numRows, winHeight/numColumns);\r\n            }\r\n        }\r\n    }\r\n    //Listener Wrapper, we don't care about the MouseEvent, but JavaFX requires it of its controller listener methods. Then we simply call doStuff();  -- Unused Right now\r\n    public void gridClicked(MouseEvent mouseEvent) {\r\n        doStuff();\r\n    }\r\n\r\n    private void drawRectangle(GraphicsContext gc,Rectangle rect){\r\n        gc.setFill(Color.DARKGREY);\r\n        gc.fillRect(rect.getX()-rect.getWidth()/2.0,\r\n                rect.getY()-rect.getHeight()/2.0,\r\n                rect.getWidth(),\r\n                rect.getHeight());\r\n        gc.setLineWidth(15);\r\n        gc.setStroke(Color.ORANGE);\r\n    }\r\n\r\n    //TODO make players able to be visable in rooms where they are as well as deleting them from rooms\r\n    //GUI to draw traps\r\n    private Rectangle drawTrap(Rectangle Rect){\r\n        Rect.setWidth(individualGridPaneWidth/3.0);\r\n        Rect.setHeight(individualGridPaneHeight/3.0);\r\n        Rect.setFill(Color.GREENYELLOW);\r\n        //Rect.setTranslateX(58);\r\n        return Rect;\r\n    }\r\n    //GUI to draw keyse\r\n    private Rectangle drawKey(Rectangle Rect){\r\n        Rect.setWidth(25);\r\n        Rect.setHeight(12);\r\n        Rect.setFill(Color.GOLD);\r\n        Rect.setTranslateX(130);\r\n        return Rect;\r\n    }\r\n\r\n\r\n    /*\r\n     * method to be called in order to draw the players\r\n     * elsewhere in the map\r\n     */\r\n    private void erasePlayer(Circle player){\r\n        mainGridPane.getChildren().remove(player);\r\n    }\r\n\r\n\r\n    //Does nothing right now, was figuring out the syntax for removing within a group env.\r\n    private void movePlayer(Player player){\r\n        if(mainGridPane.getChildren().get(mainGridPane.getChildren().size()-1).getClass() == GridPane.class)\r\n            ((GridPane)(mainGridPane.getChildren().get(mainGridPane.getChildren().size()-1))).getChildren().remove(3);\r\n    }\r\n\r\n\r\n    //Plan to move this method entirely out of doStuff, but I didn't want to break anything working right now\r\n    private void updateRoom(Room room){\r\n        double winHeight = mainGridPane.getHeight();\r\n        double winWidth = mainGridPane.getWidth();\r\n        //To keep track of when to jump down on the y offset.\r\n        int[] xYOffsets = {0, 0};\r\n\r\n        //Approximate width/height of each individual rectangle\r\n        double individualGridPaneWidth = (winWidth/gameLogic.getGridColumns());\r\n        double individualGridPaneHeight = (winHeight/gameLogic.getGridRows());\r\n\r\n        //Take the lesser of the two values ( should usually be the height, but..) and sets the radius to half that value (accounting for padding)\r\n        double radius = Math.min(individualGridPaneHeight/gameLogic.getMaxPlayers(), individualGridPaneWidth/gameLogic.getMaxPlayers())-(PADDING/2.0);\r\n\r\n        //TODO: Check if FlowPane offers an easier implementation.\r\n        GridPane startingPlayers = new GridPane();\r\n\r\n        startingPlayers.setAlignment(Pos.CENTER);\r\n        startingPlayers.setHgap(individualGridPaneHeight/gameLogic.getMaxPlayers());\r\n        startingPlayers.setVgap(PADDING);\r\n        for(int i = 0; i < gameLogic.getMaxPlayers(); i++) {\r\n            startingPlayers.add(new Circle(radius, playerColors[i%4]), xYOffsets[0], xYOffsets[1]);\r\n            xYOffsets[0]++;\r\n            if( i == gameLogic.getMaxPlayers()/2-1){\r\n                xYOffsets[0] = 0;\r\n                xYOffsets[1]++;\r\n            }\r\n        }\r\n        //Pretty sure this will always be the last child, but just in case I'm full of crap, we'll check\r\n        if(mainGridPane.getChildren().get(mainGridPane.getChildren().size()-1).getClass() == GridPane.class){\r\n            mainGridPane.getChildren().remove(mainGridPane.getChildren().size()-1);\r\n        }\r\n        mainGridPane.add(startingPlayers, room.getY(),room.getX());\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/MainGameController.java b/src/MainGameController.java
--- a/src/MainGameController.java	(revision 7a557609cb1924575ee046b6dcb6d5aaaaa6b2bf)
+++ b/src/MainGameController.java	(date 1607997952093)
@@ -76,7 +76,7 @@
         keyMap = new HashMap<>();
         playerMap = new HashMap<>();
 
-        mapInitializing();
+        gameLogic.mapInitializing(-1, -1);
         long endTime = 60;
         Label timeLabel = new Label();
         DateFormat timeFormat = new SimpleDateFormat( "HH:mm:ss" );
@@ -102,7 +102,7 @@
     number of players. By default, it generates a 9 x 9 map
     and 2 players (Justin Lamberson)
      */
-    public void mapInitializing(){
+    /*public void mapInitializing(){
         int numColumns = gameLogic.getGridColumns();
         int numRows  = gameLogic.getGridRows();
         System.out.println(numColumns + " " + numRows);
@@ -139,7 +139,7 @@
         playerMap.put(1, new Player(mapLayout[0][0]));
         playerMap.put(2, new Player(mapLayout[0][1]));
 
-    }
+    }*/
 
     private void setGridPaneUp(){
         for (int i = 0 ; i < gameLogic.getGridRows(); i++) {
@@ -300,7 +300,7 @@
     }
 
 
-    /*
+    /**
      * method to be called in order to draw the players
      * elsewhere in the map
      */
Index: src/TextTester.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/TextTester.java b/src/TextTester.java
new file mode 100644
--- /dev/null	(date 1607999705885)
+++ b/src/TextTester.java	(date 1607999705885)
@@ -0,0 +1,21 @@
+public class TextTester {
+    public static void main(String[] args) {
+        GameLogic gamelogic = new GameLogic();
+
+        for (int x = 0; x < gamelogic.getGridRows(); x++) {
+            for (int y = 0; y < gamelogic.getGridColumns(); y++) {
+                Room room = gamelogic.getRoom(x, y);
+                System.out.println("Room Coords: " + room.getX() + ", " + room.getY() + "\nIs locked? " + room.isLocked() + "\nDoor ID: " + room.getDoorID() + "\nTrapped? " + room.isATrap());
+                System.out.print("Key? ");
+                if (room.getKey() == null) {
+                    System.out.println("No\n");
+                } else {
+                    System.out.println("Yes. Unlocks roomID: " + room.getKey().getMyRoom().getDoorID() + "\n");
+                }
+
+            }
+        }
+
+
+    }
+}
