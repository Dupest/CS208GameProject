Index: src/MainGameController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import javafx.fxml.FXML;\r\nimport javafx.geometry.Point2D;\r\nimport javafx.scene.Group;\r\nimport javafx.scene.Node;\r\nimport javafx.scene.canvas.Canvas;\r\nimport javafx.scene.canvas.GraphicsContext;\r\nimport javafx.scene.input.MouseEvent;\r\nimport javafx.scene.layout.GridPane;\r\nimport javafx.scene.layout.VBox;\r\nimport javafx.scene.paint.Color;\r\nimport javafx.scene.shape.Rectangle;\r\n\r\nimport java.awt.*;\r\nimport java.util.*;\r\nimport javafx.scene.shape.Circle;\r\n\r\n//Edited By Svetozar Draganitchki\r\npublic class MainGameController {\r\n\r\n    //We keep track of the canvases and gridPane node refs since they're made dynamically\r\n    private Node[][] gridPaneNodes;\r\n    private Node[][] canvases;\r\n    private GameLogic gameLogic;\r\n\r\n    //References to our main window objects for easier coding/listeners yada-yada\r\n    @FXML\r\n    private VBox rootPane;\r\n\r\n    @FXML\r\n    private GridPane mainGridPane;\r\n\r\n    private Room[][]  mapLayout;\r\n    private HashMap<Integer, Key> keyList;\r\n    private HashMap<Integer, Player> playerList;\r\n    \r\n    private GameLogic GL;\r\n\r\n    private static final int PADDING = 10;\r\n\r\n    /**\r\n     * This runs first whenever application tester calls Loader.load() so it acts as the driver code for our JavaFX project\r\n     */\r\n    public void initialize() {\r\n\r\n        //We can get them number of columns/rows by checking to see how many constraints there are. There will be a specific constraint object for each row/column\r\n        int numColumns = mainGridPane.getColumnConstraints().size();\r\n        int numRows  = mainGridPane.getRowConstraints().size();\r\n\r\n        //Init arrays\r\n        gridPaneNodes = new Node[numRows][numColumns];\r\n        canvases = new Node[numRows][numColumns];\r\n        mapLayout = new Room[numRows][numColumns];\r\n        populateArray();\r\n\r\n        //We bind a listener to the size of the window to allow things to resize smoothly. resizing calls doStuff()\r\n        mainGridPane.heightProperty().addListener(evt -> doStuff());\r\n        mainGridPane.widthProperty().addListener(evt -> doStuff());\r\n\r\n        //Creates the \"map\" of rooms, players, and Keys\r\n        keyList = new HashMap<>();\r\n        playerList = new HashMap<>();\r\n        GL = new GameLogic();\r\n        mapInitializing();\r\n    }\r\n    /*\r\n    initializes the map depending on the size of the map and\r\n    number of players. By default, it generates a 9 x 9 map\r\n    and 2 players (Justin Lamberson)\r\n     */\r\n    public void mapInitializing(){\r\n        int numColumns = mainGridPane.getColumnConstraints().size();\r\n        int numRows  = mainGridPane.getRowConstraints().size();\r\n        //assumes that there are 2 players and a 9 x 9 map\r\n        Random rand = new Random();\r\n\r\n        //traps is max number of traps\r\n        int traps = 10;\r\n        int roomNumber = 1;\r\n\r\n        //loop initializes all rooms\r\n        for(int i = 0; i < numRows; i++){\r\n            for(int k = 0; k < numColumns; k++){\r\n                if(rand.nextInt(101) < 50 || traps >= 0){\r\n                    traps--;\r\n                    mapLayout[i][k] = new Room(false, roomNumber, true);\r\n\r\n                //If last room ie (8,8)\r\n                }else if(i == numRows-1 && k == numColumns-1){\r\n\r\n                    //Make special constructor for the final room so this is different from else loop\r\n                    mapLayout[i][k] = new Room(true, roomNumber, false);\r\n                } else {\r\n                    mapLayout[i][k] = new Room(false, roomNumber, false);\r\n                }\r\n                roomNumber++;\r\n            }\r\n        }\r\n        System.out.println(roomNumber);\r\n        //generates final key =\r\n        //keyList.put(81, new Key(mapLayout[8][8] ,1));\r\n\r\n        //generates the two players in the top 2 rooms\r\n        playerList.put(1, new Player(mapLayout[0][0]));\r\n        playerList.put(2, new Player(mapLayout[0][1]));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Draw things\r\n     */\r\n    private void doStuff(){\r\n        int numColumns = mainGridPane.getColumnConstraints().size();\r\n        int numRows  = mainGridPane.getRowConstraints().size();\r\n\r\n        //First call to doStuff() will be in the initialize() method and for do to order of the loader's ops, getHeight() and getWidth() will return 0 at this point.\r\n        // So we call the prefHeight/Width in that case.\r\n        double winHeight = mainGridPane.getHeight();\r\n        double winWidth = mainGridPane.getWidth();\r\n        if(winHeight == 0 || winWidth == 0){\r\n            winHeight = mainGridPane.getPrefHeight();\r\n            winWidth = mainGridPane.getPrefWidth();\r\n        }\r\n\r\n        //Another hacky solution that I've found. getChildren().clear() removes the gridlines on our gridpane. However, this information is stored within the very first\r\n        //child so we simply store that through the deletion, and fit it back in to regain our lines.\r\n        Node node = mainGridPane.getChildren().get(0);\r\n        mainGridPane.getChildren().clear();\r\n        mainGridPane.getChildren().add(0, node);\r\n        GraphicsContext gc = null;\r\n        Canvas newMapImage = null;\r\n        //For each node within the gridpane draw a circle representing a room.\r\n        for(int i = 0; i < numRows; i++){\r\n            for(int k = 0; k < numColumns; k++){\r\n\r\n                //Think there's a better way to do this, but default behavior each gridpane node gets a percent of the screen X based on number of children C (size = X/C)\r\n                 newMapImage = new Canvas(winWidth/numRows, winHeight/numColumns);\r\n                canvases[i][k] = newMapImage;\r\n\r\n                //Returns a graphics object of the canvas for drawing\r\n                gc = newMapImage.getGraphicsContext2D();\r\n                Rectangle newRect = new Rectangle\r\n                        (newMapImage.getWidth()/2.0, newMapImage.getHeight()/2.0, newMapImage.getWidth()-PADDING, newMapImage.getHeight()-PADDING);\r\n                \r\n                System.out.println(\"W:\" + newMapImage.getWidth());\r\n                System.out.println(\"H:\" + newMapImage.getHeight());\r\n\r\n                mapLayout[i][k].setRoomRender(newRect);\r\n                drawRectangle(gc, newRect);\r\n                \r\n                //My custom circle class from the last project we did because I wanted a quick lazy drawing to show this off.\r\n                //CircleWithText mapCircle = new CircleWithText(\"Map (\" + i + \", \" + k + \")\", new Point2D(newMapImage.getWidth()/2.0,newMapImage.getHeight()/2.0));\r\n\r\n//                //Default radius on the circles is 40, but if we start to get smaller screen sizes to where each node only has 80 pixels of room in any direction, we adjust the radius.\r\n//                if(newMapImage.getHeight() < mapCircle.getDefRadius()*2 || newMapImage.getWidth() < mapCircle.getDefRadius()*2){\r\n//\r\n//                    //We take the smaller of the two values\r\n//                    double smallerBound = Math.min(newMapImage.getHeight(), newMapImage.getWidth());\r\n//                    //double smallerBound =(newMapImage.getHeight() > newMapImage.getWidth()) ? newMapImage.getWidth(): newMapImage.getHeight();\r\n//\r\n//                    //Radius becomes half of the smallest distance to an edge.\r\n//                    mapCircle.setRadius((int)(smallerBound/2.0));\r\n//                    mapCircle.drawCusRadius(gc);\r\n//                }\r\n//\r\n//                //Otherwise we draw it normally\r\n//                else\r\n//                    mapCircle.draw(gc);\r\n                //System.out.println(\"Circle coords: \" + mapCircle.getPoint());\r\n                Group newGroup = new Group();\r\n                newGroup.getChildren().add(newMapImage);\r\n                mainGridPane.add(newGroup, i, k);\r\n                \r\n            }\r\n        }\r\n        //Way to draw traps\r\n//        for(int i = 0; i <81; i++){\r\n//            if(GL.getRoom(i).hasKey())\r\n                mainGridPane.add(drawTrap(new Rectangle()),3,4); //mainGridPane.add(drawTrap(new Rectangle()),GL.getRoom(i).getX(), GL.getRoom(i).getY());\r\n//        }\r\n        \r\n        //Generates 4 Players.\r\n        Circle player1Graphic = new Circle\r\n                        (newMapImage.getWidth()/2.0, newMapImage.getHeight(),15);\r\n        Circle player2Graphic = new Circle\r\n                        (newMapImage.getWidth()/2.0, newMapImage.getHeight(),15);\r\n        Circle player3Graphic = new Circle\r\n                        (newMapImage.getWidth()/2.0, newMapImage.getHeight(),15);\r\n        Circle player4Graphic = new Circle\r\n                        (newMapImage.getWidth()/2.0, newMapImage.getHeight(),15);\r\n        //sets colors of 4 players\r\n        drawPlayer1(player1Graphic);\r\n        drawPlayer2(player2Graphic);\r\n        drawPlayer3(player3Graphic);\r\n        drawPlayer4(player4Graphic);\r\n        //adds 4 players to nodes the commented out code is how to add the players when we have them working.\r\n        mainGridPane.add(player1Graphic, 4, 4); //mainGridPane.add(player1Graphic, GL.getPlayer(2).getX(), GL.getPlayer(1).getY());\r\n        mainGridPane.add(player2Graphic, 0, 5); //mainGridPane.add(player2Graphic, GL.getPlayer(2).getX(), GL.getPlayer(1).getY());\r\n        mainGridPane.add(player3Graphic, 1, 2); //mainGridPane.add(player3Graphic, GL.getPlayer(2).getX(), GL.getPlayer(1).getY());\r\n        mainGridPane.add(player4Graphic, 3, 1); //mainGridPane.add(player4Graphic, GL.getPlayer(2).getX(), GL.getPlayer(1).getY());\r\n\r\n        mainGridPane.add(drawKey(new Rectangle()), 7, 7);\r\n        \r\n        //Groups just add an extra layer of organization. In this case not necessary, but trying to show of some of the syntax too\r\n\r\n    }\r\n\r\n    private void populateArray(){\r\n        for (Node child : mainGridPane.getChildren()) {\r\n            Integer column = GridPane.getColumnIndex(child);\r\n            Integer row = GridPane.getRowIndex(child);\r\n            if (column != null && row != null) {\r\n                gridPaneNodes[column][row] = child;\r\n            }\r\n        }\r\n        int numColumns = mainGridPane.getColumnConstraints().size();\r\n        int numRows  = mainGridPane.getRowConstraints().size();\r\n        double winHeight = mainGridPane.getHeight();\r\n        double winWidth = mainGridPane.getWidth();\r\n        if(winHeight == 0 || winWidth == 0){\r\n            winHeight = mainGridPane.getPrefHeight();\r\n            winWidth = mainGridPane.getPrefWidth();\r\n        }\r\n        for(int i = 0; i < canvases.length; i++){\r\n            for(int k = 0; k < canvases[0].length; k++){\r\n                canvases[i][k] = new Canvas(winWidth/numRows, winHeight/numColumns);\r\n            }\r\n        }\r\n    }\r\n    //Listener Wrapper, we don't care about the MouseEvent, but JavaFX requires it of its controller listener methods. Then we simply call doStuff();  -- Unused Right now\r\n    public void gridClicked(MouseEvent mouseEvent) {\r\n        doStuff();\r\n    }\r\n\r\n    private void drawRectangle(GraphicsContext gc,Rectangle rect){\r\n        gc.setFill(Color.DARKGREY);\r\n        gc.fillRect(rect.getX()-rect.getWidth()/2.0,\r\n                rect.getY()-rect.getHeight()/2.0,\r\n                rect.getWidth(),\r\n                rect.getHeight());\r\n        gc.setFill(Color.GREEN);\r\n        gc.setStroke(Color.ORANGE);\r\n    }\r\n\r\n    //TODO make players able to be visable in rooms where they are as well as deleting them from rooms\r\n\r\n\r\n    //Sets the Colors and Sizes of different players\r\n        \r\n    private void drawPlayer1(Circle Circle){\r\n        Circle.setFill(javafx.scene.paint.Color.DARKBLUE);\r\n        Circle.setTranslateX(70);\r\n        Circle.setTranslateY(20);\r\n    }\r\n    \r\n    private void drawPlayer2(Circle Circle){\r\n        Circle.setFill(javafx.scene.paint.Color.CRIMSON);\r\n        Circle.setTranslateX(70);\r\n        Circle.setTranslateY(20);\r\n    }\r\n    \r\n    private void drawPlayer3(Circle Circle){\r\n        Circle.setFill(javafx.scene.paint.Color.BLUEVIOLET);\r\n        Circle.setTranslateX(70);\r\n        Circle.setTranslateY(20);\r\n    }\r\n    \r\n    private void drawPlayer4(Circle Circle){\r\n        Circle.setFill(javafx.scene.paint.Color.CORAL);\r\n        Circle.setTranslateX(70);\r\n        Circle.setTranslateY(20);\r\n    }\r\n    //GUI to draw traps\r\n    private Rectangle drawTrap(Rectangle Rect){\r\n        Rect.setWidth(50);\r\n        Rect.setHeight(50);\r\n        Rect.setFill(Color.GREENYELLOW);\r\n        Rect.setTranslateX(58);\r\n        return Rect;\r\n    }\r\n    //GUI to draw keyse\r\n    private Rectangle drawKey(Rectangle Rect){\r\n        Rect.setWidth(25);\r\n        Rect.setHeight(12);\r\n        Rect.setFill(Color.GOLD);\r\n        Rect.setTranslateX(130);\r\n        return Rect;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/MainGameController.java b/src/MainGameController.java
--- a/src/MainGameController.java	(revision 13cff202042c9377689eea67e2cee126cbdfce53)
+++ b/src/MainGameController.java	(date 1607833658174)
@@ -175,10 +175,12 @@
             }
         }
         //Way to draw traps
-//        for(int i = 0; i <81; i++){
-//            if(GL.getRoom(i).hasKey())
-                mainGridPane.add(drawTrap(new Rectangle()),3,4); //mainGridPane.add(drawTrap(new Rectangle()),GL.getRoom(i).getX(), GL.getRoom(i).getY());
-//        }
+        for(int i = 1; i < 81; i++){
+            if(GL.getRoom(i).isATrap()) {
+                Room currRoom = GL.getRoom(i);
+                mainGridPane.add(drawTrap(new Rectangle()), currRoom.getX(), currRoom.getY());
+            }
+        }
         
         //Generates 4 Players.
         Circle player1Graphic = new Circle
@@ -203,7 +205,6 @@
         mainGridPane.add(drawKey(new Rectangle()), 7, 7);
         
         //Groups just add an extra layer of organization. In this case not necessary, but trying to show of some of the syntax too
-
     }
 
     private void populateArray(){
@@ -287,4 +288,14 @@
         Rect.setTranslateX(130);
         return Rect;
     }
+
+
+    /*
+     * method to be called in order to draw the players
+     * elsewhere in the map
+     */
+    private void erasePlayer(Circle player){
+        mainGridPane.getChildren().remove(player);
+    }
+
 }
\ No newline at end of file
Index: src/Room.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import javafx.scene.shape.Rectangle;\r\n\r\nimport java.util.*;\r\n\r\n// Edited By Svetozar Draganitchki\r\npublic class Room {\r\n    private boolean isLocked;\r\n    private int doorID;\r\n    private boolean isATrap;\r\n    private Rectangle roomRender;\r\n\r\n    HashMap<Integer, Player> playersInside = new HashMap<>(); //TODO check hashmap implementation\r\n    \r\n    private Key isKey;\r\n    private int x,y;\r\n\r\n\r\n    public Room(){\r\n        this.isLocked = false;\r\n        this.doorID = -1;\r\n        this.isATrap = false;\r\n        this.isKey = null;\r\n        this.roomRender = null;\r\n    }\r\n    public Room(boolean isLocked, int doorID, boolean isATrap) {\r\n        this.isLocked = isLocked;\r\n        this.doorID = doorID;\r\n        this.isATrap = isATrap;\r\n        this.roomRender = null;\r\n    }\r\n    \r\n    //By Svetozar Draganitchki\r\n    public Room(boolean isLocked, int doorID, boolean isATrap, int x, int y) {\r\n        this.isLocked = isLocked;\r\n        this.doorID = doorID;\r\n        this.isATrap = isATrap;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.roomRender = null;\r\n    }\r\n    //By Svetozar Draganitchki\r\n    public Room(boolean isLocked, int doorID, boolean isATrap, Key isKey) {\r\n        this.isLocked = isLocked;\r\n        this.doorID = doorID;\r\n        this.isATrap = isATrap;\r\n        this.isKey = isKey;\r\n        this.roomRender = null;\r\n    }\r\n    //By Svetozar Draganitchki\r\n    public Room(boolean isLocked, int doorID, boolean isATrap, Key isKey, int x, int y) {\r\n        this.isLocked = isLocked;\r\n        this.doorID = doorID;\r\n        this.isATrap = isATrap;\r\n        this.isKey = isKey;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.roomRender = null;\r\n    }\r\n\r\n    public boolean isLocked() {\r\n        return isLocked;\r\n    }\r\n\r\n    public void setLock(boolean locked) {\r\n        isLocked = locked;\r\n    }\r\n\r\n    public int getDoorID() {\r\n        return doorID;\r\n    }\r\n\r\n    public void setDoorID(int doorID) {\r\n        this.doorID = doorID;\r\n    }\r\n\r\n    public boolean isATrap() {\r\n        return isATrap;\r\n    }\r\n\r\n    public void setATrap(boolean ATrap) {\r\n        isATrap = ATrap;\r\n    }\r\n    \r\n    public void setKey(Key a){\r\n        isKey = a;\r\n    }\r\n    \r\n    public Key getKey(){\r\n        return isKey;\r\n    }\r\n    \r\n    public int getX(){\r\n        return x;\r\n    }\r\n    \r\n    public int getY(){\r\n        return y;\r\n    }\r\n    \r\n    public boolean hasKey(){\r\n        if(isKey == null)\r\n            return false;\r\n        else \r\n            return true;\r\n    }\r\n\r\n    /*TODO: Reconsider these two. We probably don't need to check for the booleans because they'll change. We can, but room.doorID should be unique from it's implementation anyway  */\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o) return true;\r\n        if (o == null || getClass() != o.getClass()) return false;\r\n        Room room = (Room) o;\r\n        return doorID == room.doorID;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return Objects.hash(doorID, isATrap);\r\n    }\r\n\r\n    /*checks for a trap when a player comes into a room\r\n     *if room does have a trap, the player takes a random amount damage\r\n     * Damage taken can be no less than 1\r\n     * In addition\r\n     * Justin Lamberson\r\n     */\r\n    public void playerEntry(int playerID, Player player){\r\n        playersInside.put(playerID, player);\r\n        Random rand = new Random();\r\n        //Math.random() * (max-min+1) + min   - Will return in range\r\n        int damageTaken = rand.nextInt(5);\r\n        if(isATrap){\r\n            if(damageTaken == 0){ //check prevents the damage taken not to be less than 1\r\n                player.trapTriggered();\r\n                isATrap = false;\r\n            } else {\r\n                player.trapTriggered(damageTaken);\r\n                isATrap = false;\r\n            }\r\n        }\r\n        playersInside.put(playerID, player);\r\n    }\r\n    \r\n    /*\r\n     * method for removing a player from a room and returning that player\r\n     * -Justin Lamberson\r\n     * TODO should table be rehashed in this method? -JL\r\n     */\r\n    public Player playerExiting(int playerID){\r\n        Player player = playersInside.get(playerID);\r\n        playersInside.remove(playerID);\r\n        return player;\r\n    }\r\n\r\n    //TODO move triggered trap to room\r\n\r\n\r\n    public void setLocked(boolean locked) {\r\n        isLocked = locked;\r\n    }\r\n\r\n    public Rectangle getRoomRender() {\r\n        return roomRender;\r\n    }\r\n\r\n    public void setRoomRender(Rectangle roomRender) {\r\n        this.roomRender = roomRender;\r\n    }\r\n\r\n    public HashMap<Integer, Player> getPlayersInside() {\r\n        return playersInside;\r\n    }\r\n\r\n    public void setPlayersInside(HashMap<Integer, Player> playersInside) {\r\n        this.playersInside = playersInside;\r\n    }\r\n\r\n    /*\r\n     * a debug method in order to populate the room with both a player\r\n     * and a key\r\n     */\r\n    public void debugInitialize(){\r\n        for(int i = 1; i < 5; i++){\r\n            playersInside.put(i, new Player());\r\n        }\r\n        isKey = new Key();\r\n\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Room.java b/src/Room.java
--- a/src/Room.java	(revision 13cff202042c9377689eea67e2cee126cbdfce53)
+++ b/src/Room.java	(date 1607833263892)
@@ -131,10 +131,10 @@
         int damageTaken = rand.nextInt(5);
         if(isATrap){
             if(damageTaken == 0){ //check prevents the damage taken not to be less than 1
-                player.trapTriggered();
+                player.setHealthPool((player.getHealthPool() - 1));
                 isATrap = false;
             } else {
-                player.trapTriggered(damageTaken);
+                player.setHealthPool((player.getHealthPool() - damageTaken));
                 isATrap = false;
             }
         }
@@ -152,7 +152,7 @@
         return player;
     }
 
-    //TODO move triggered trap to room
+    // move triggered trap to room - resolved in player entry
 
 
     public void setLocked(boolean locked) {
Index: src/Player.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import java.util.ArrayList;\r\nimport java.util.HashMap;\r\n\r\n//Edited By Svetozar Draganitchki\r\npublic class Player {\r\n\r\n    private CircleWithText playerRender;\r\n    private static final int DEFAULT_HEALTH = 15;\r\n    private HashMap<String, String> playersMap; ///I think this might be useless -Svet\r\n    //What is this used for -Justin L\r\n\r\n    //TODO: Pick one of these two\r\n  //  private ArrayList<Key> keyList; \r\n    private HashMap<Integer, Key> keyList;\r\n    //private int numKeys;\r\n    private Room currentRoom;\r\n    private int healthPool;\r\n    \r\n    //variables to keep track of player location\r\n    private int x,y;\r\n    \r\n    public Player(){\r\n        healthPool = DEFAULT_HEALTH;\r\n        keyList = null;\r\n        currentRoom = null;\r\n        playersMap = new HashMap<>();\r\n    }\r\n\r\n    public Player(Room initalRoom){\r\n        healthPool = DEFAULT_HEALTH;\r\n        keyList = null;\r\n        currentRoom = null;\r\n        playersMap = new HashMap<>();\r\n    }\r\n    \r\n    //By Svetozar Draganitchki\r\n    public Player(int x,int y){\r\n        healthPool = DEFAULT_HEALTH;\r\n        keyList = null;\r\n        currentRoom = null;\r\n        playersMap = new HashMap<>();\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    public void playerDead(){\r\n        if(healthPool <= 0){\r\n            currentRoom = null;\r\n        }\r\n    }\r\n    /*\r\n     *if a trap is triggered, by default, damage taken is one\r\n     */\r\n    public void trapTriggered(){\r\n        healthPool--;\r\n    }\r\n\r\n    /*\r\n     * Overloaded method does the same thing as the default method\r\n     * but, it allows the damage taken to be set\r\n     */\r\n    public void trapTriggered(int damage){\r\n        healthPool -= damage;\r\n    }\r\n\r\n    public int getHealthPool(){\r\n        return healthPool;\r\n    }\r\n    \r\n    public Key getKey(int keyID){\r\n        return keyList.get(keyID);\r\n    }\r\n     \r\n     public void setKey(int keyID,Key key){\r\n        keyList.put(keyID,key);\r\n    } \r\n    \r\n\r\n    //By Svetozar Draganitchki\r\n    public void moveRight(){\r\n        x++;\r\n    }\r\n    \r\n    public void moveLeft(){\r\n        x--;\r\n    }\r\n    \r\n    public void moveForward(){\r\n        y++;\r\n    }\r\n    \r\n    public void moveBackward(){\r\n        y--;\r\n    }\r\n    \r\n    public int getX(){\r\n        return x;\r\n    }\r\n    public int getY(){\r\n        return y;\r\n    }\r\n}\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Player.java b/src/Player.java
--- a/src/Player.java	(revision 13cff202042c9377689eea67e2cee126cbdfce53)
+++ b/src/Player.java	(date 1607833263904)
@@ -51,21 +51,25 @@
     /*
      *if a trap is triggered, by default, damage taken is one
      */
-    public void trapTriggered(){
+    /*public void trapTriggered(){
         healthPool--;
-    }
+    }*/
 
     /*
      * Overloaded method does the same thing as the default method
      * but, it allows the damage taken to be set
      */
-    public void trapTriggered(int damage){
+    /*public void trapTriggered(int damage){
         healthPool -= damage;
-    }
+    }*/
 
     public int getHealthPool(){
         return healthPool;
     }
+
+    public void setHealthPool(int newHealth){
+        healthPool = newHealth;
+    }
     
     public Key getKey(int keyID){
         return keyList.get(keyID);
Index: src/GameLogic.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import java.awt.event.KeyEvent;\r\nimport java.awt.event.KeyListener;\r\nimport java.util.HashMap;\r\nimport java.util.Random;\r\n\r\n/*\r\n * To change this license header, choose License Headers in Project Properties.\r\n * To change this template file, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\n\r\n/**\r\n *  By Svetozar Draganitchki\r\n * \r\n */\r\npublic class GameLogic implements KeyListener{\r\n    //TODO: Figure out rehashing - how do we actually do it, is it an automatic call?\r\n    private HashMap<Integer, Room>  mapLayout;                                          //TODO: Change to 2D array potentially.\r\n    private HashMap<Integer, Key> keyList;\r\n    private HashMap<Integer, Player> playerList;\r\n    private static final int MAXPLAYERS = 4;\r\n\r\n    \r\n    public GameLogic(){\r\n        mapLayout = new HashMap<Integer, Room> ();\r\n        keyList = new HashMap<Integer, Key> ();\r\n        playerList = new HashMap<Integer, Player> ();\r\n        mapInitializing();\r\n    }\r\n    \r\n    public GameLogic( HashMap<Integer, Room>  mapLayout, HashMap<Integer, Key> keyList, HashMap<Integer, Player> playerList){\r\n        this.mapLayout = mapLayout;\r\n        this.keyList = keyList;\r\n        this.playerList = playerList;\r\n        mapInitializing();\r\n    }\r\n  \r\n\r\n    \r\n    /*\r\n    initializes the map depending on the size of the map and\r\n    number of players. By default, it generates a 9 x 9 map\r\n    and 2 players\r\n     */\r\n    public void mapInitializing(){\r\n        //assumes that there are 2 players and a 9 x 9 map\r\n        Random rand = new Random();\r\n\r\n        //traps is max number of traps\r\n        int traps = 10;\r\n        int roomNumber = 1;\r\n\r\n        //loop initializes all rooms\r\n//        for(int i = 0; i < 81; i++){\r\n//            if(rand.nextInt(101) < 50 || traps >= 0){\r\n//                traps--;\r\n//                mapLayout.put(roomNumber, new Room(false, roomNumber, true, new Key(mapLayout.get(i) ,1) ));\r\n//                roomNumber++;\r\n//            }else if(roomNumber == 81){\r\n//                mapLayout.put(roomNumber, new Room(true, roomNumber, false, new Key(mapLayout.get(i) ,1) ));\r\n//            } else {\r\n//                mapLayout.put(roomNumber, new Room(false, roomNumber, false, new Key(mapLayout.get(i) ,1) ));\r\n//                roomNumber++;\r\n//            }\r\n//        }\r\n        //loop initializes all rooms\r\n        for(int y = 0 ; y < 9; y ++)\r\n        {\r\n            for(int x = 0 ; x < 9; x ++)\r\n            {\r\n                if(rand.nextInt(10) <= 5 || traps >= 0){\r\n                    mapLayout.put(roomNumber, new Room(false, roomNumber, true, x, y));\r\n                    traps --;\r\n                    roomNumber ++;\r\n                } else if (x == 8 && y == 0){\r\n                    mapLayout.put(roomNumber, new Room(true, roomNumber, false, x, y));\r\n                    roomNumber++;\r\n                }\r\n                else\r\n                {\r\n                    mapLayout.put(roomNumber, new Room(true, roomNumber, false, x, y));\r\n                    roomNumber++;\r\n                }\r\n            }\r\n        }\r\n        \r\n        //generates final key =\r\n        keyList.put(81, new Key(mapLayout.get(81) ,1));\r\n        \r\n        //generates keys\r\n        for(int i = 1; i <= 10; i++)\r\n        {\r\n            mapLayout.get(i).setLock(true);\r\n            keyList.put(i, new Key(mapLayout.get(rand.nextInt(81)),1));\r\n        }\r\n        \r\n\r\n        //generates the two players in the top 2 rooms\r\n        playerList.put(1, new Player(mapLayout.get(rand.nextInt(10)))); // playerList.put(1, new Player(0,8));\r\n        playerList.put(2, new Player(mapLayout.get(rand.nextInt(10)))); // playerList.put(1, new Player(0,7));\r\n\r\n    }\r\n    \r\n    //Only to be used after implmenting mapInitializing() not sure about using this, ***** DON'T LIKE THIS ******\r\n    public int[][] to2DArray(){\r\n        int[][] room2d = new int[9][9];\r\n        int x = 0;\r\n        int y = 0;\r\n        for(HashMap.Entry<Integer, Room> entry : mapLayout.entrySet())\r\n        {\r\n            if(x >= 9)\r\n            {\r\n                if(y >= 9)\r\n                {\r\n                    room2d[x][y] = entry.getKey();\r\n                    y = 0;\r\n                    x = 0;\r\n                }\r\n                else\r\n                {\r\n                    room2d[x][y] = entry.getKey();\r\n                    y++;\r\n                    x = 0;\r\n                }\r\n            }\r\n            else\r\n            {\r\n               if(y >= 9)\r\n                {\r\n                    room2d[x][y] = entry.getKey();\r\n                    y = 0;\r\n                    x++;\r\n                }\r\n                else\r\n                {\r\n                    room2d[x][y] = entry.getKey();\r\n                    y++;\r\n                    x++;\r\n                }\r\n            }\r\n        }\r\n        return room2d;\r\n    }\r\n\r\n    /*\r\n     * method allows there to be a set amount of both\r\n     * players and trapped rooms at the initialization of the\r\n     * game -Justin Lamberson\r\n     */\r\n    public void mapInitializing(int players, int trappedRooms){\r\n        //method assumes the map generated is a 9 x 9\r\n        Random rand = new Random();\r\n\r\n        //traps is max number of traps\r\n        int traps = trappedRooms;\r\n        int roomNumber = 1;\r\n\r\n        //loop initializes all rooms\r\n//        for(int i = 0; i < 81; i++){\r\n//            if(rand.nextInt(101) < 50 || traps >= 0){\r\n//                traps--;\r\n//                mapLayout.put(roomNumber, new Room(false, roomNumber, true, new Key(mapLayout.get(i) ,1) ));\r\n//                roomNumber++;\r\n//            }else if(roomNumber == 81){\r\n//                mapLayout.put(roomNumber, new Room(true, roomNumber, false, new Key(mapLayout.get(i) ,1) ));\r\n//            } else {\r\n//                mapLayout.put(roomNumber, new Room(false, roomNumber, false, new Key(mapLayout.get(i) ,1) ));\r\n//                roomNumber++;\r\n//            }\r\n//        }\r\n        //loop initializes all rooms\r\n        for(int y = 0 ; y < 9; y ++)\r\n        {\r\n            for(int x = 0 ; x < 9; x ++)\r\n            {\r\n                if(rand.nextInt(10) <= 5 || traps >= 0){\r\n                    mapLayout.put(roomNumber, new Room(false, roomNumber, true, x, y));\r\n                    traps --;\r\n                    roomNumber ++;\r\n                } else if (x == 8 && y == 0){\r\n                    mapLayout.put(roomNumber, new Room(true, roomNumber, false, x, y));\r\n                    roomNumber++;\r\n                }\r\n                else\r\n                {\r\n                    mapLayout.put(roomNumber, new Room(true, roomNumber, false, x, y));\r\n                    roomNumber++;\r\n                }\r\n            }\r\n        }\r\n\r\n        //generates final key =\r\n        keyList.put(81, new Key(mapLayout.get(81) ,1));\r\n\r\n        //generates keys\r\n        for(int i = 1; i <= 10; i++)\r\n        {\r\n            mapLayout.get(i).setLock(true);\r\n            keyList.put(i, new Key(mapLayout.get(rand.nextInt(81)),1));\r\n        }\r\n\r\n\r\n        //generates the number of players specified by the variable players\r\n        //generates the players at the top of the map\r\n        for(int i = 1; i <= players; i++){\r\n            playerList.put(i, new Player(mapLayout.get(rand.nextInt(10))));\r\n        }\r\n\r\n    }\r\n    /*\r\n     * method assumes the map is a 9 x 9 and that there are only 2 players\r\n     * -Justin Lamberson\r\n     */\r\n    public void mapInitializing(int trappedRooms){\r\n        Random rand = new Random();\r\n\r\n        //traps is max number of traps\r\n        int traps = 10;\r\n        int roomNumber = 1;\r\n\r\n        //loop initializes all rooms\r\n//        for(int i = 0; i < 81; i++){\r\n//            if(rand.nextInt(101) < 50 || traps >= 0){\r\n//                traps--;\r\n//                mapLayout.put(roomNumber, new Room(false, roomNumber, true, new Key(mapLayout.get(i) ,1) ));\r\n//                roomNumber++;\r\n//            }else if(roomNumber == 81){\r\n//                mapLayout.put(roomNumber, new Room(true, roomNumber, false, new Key(mapLayout.get(i) ,1) ));\r\n//            } else {\r\n//                mapLayout.put(roomNumber, new Room(false, roomNumber, false, new Key(mapLayout.get(i) ,1) ));\r\n//                roomNumber++;\r\n//            }\r\n//        }\r\n        //loop initializes all rooms\r\n        for(int y = 0 ; y < 9; y ++)\r\n        {\r\n            for(int x = 0 ; x < 9; x ++)\r\n            {\r\n                if(rand.nextInt(10) <= 5 || traps >= 0){\r\n                    mapLayout.put(roomNumber, new Room(false, roomNumber, true, x, y));\r\n                    traps --;\r\n                    roomNumber ++;\r\n                } else if (x == 8 && y == 0){\r\n                    mapLayout.put(roomNumber, new Room(true, roomNumber, false, x, y));\r\n                    roomNumber++;\r\n                }\r\n                else\r\n                {\r\n                    mapLayout.put(roomNumber, new Room(true, roomNumber, false, x, y));\r\n                    roomNumber++;\r\n                }\r\n            }\r\n        }\r\n\r\n        //generates final key =\r\n        keyList.put(81, new Key(mapLayout.get(81) ,1));\r\n\r\n        //generates keys\r\n        for(int i = 1; i <= 10; i++)\r\n        {\r\n            mapLayout.get(i).setLock(true);\r\n            keyList.put(i, new Key(mapLayout.get(rand.nextInt(81)),1));\r\n        }\r\n\r\n\r\n        //generates the two players in the top 2 rooms\r\n        playerList.put(1, new Player(mapLayout.get(rand.nextInt(10)))); // playerList.put(1, new Player(0,8));\r\n        playerList.put(2, new Player(mapLayout.get(rand.nextInt(10)))); // playerList.put(1, new Player(0,7));\r\n    }\r\n    /*\r\n        By Svetozar Draganitchki\r\n        method that checks if player can enter room\r\n    */\r\n    public boolean canEnter(int roomNumber,Player p){\r\n        if(mapLayout.get(roomNumber).isLocked()){\r\n            return hasKey(roomNumber, p);           //Simplified this logic - DO\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    /*\r\n        By Svetozar Draganitchki\r\n        checks if a player has the matching key to a room\r\n    */\r\n    public boolean hasKey(int roomNumber,Player p){\r\n        return mapLayout.get(roomNumber).getKey().equals(p.getKey(mapLayout.get(roomNumber).getDoorID()));  //Simplified this logic - DO\r\n    }\r\n    \r\n    public void EnteredRoom(int roomNumber,Player p){\r\n        if(canEnter(roomNumber,p)){\r\n            \r\n        }\r\n    }\r\n    \r\n    public Player getPlayer(int playerID){\r\n        return playerList.get(playerID);\r\n    }\r\n    \r\n    public Key getKeyMap(int keyID){\r\n        return keyList.get(keyID);\r\n    }\r\n    \r\n    public Room getRoom(int roomNumber){\r\n        return mapLayout.get(roomNumber);\r\n    }\r\n    \r\n    @Override\r\n    public void keyTyped(KeyEvent e) {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void keyPressed(KeyEvent e) {\r\n        if (e.getKeyCode() == KeyEvent.VK_RIGHT ||\r\n            e.getKeyCode() == KeyEvent.VK_D) {\r\n            System.out.println(\"Right key Released\");\r\n            \r\n        }\r\n        if (e.getKeyCode() == KeyEvent.VK_LEFT ||\r\n            e.getKeyCode() == KeyEvent.VK_A) {\r\n            System.out.println(\"Left key Released\");\r\n            \r\n        }\r\n        if (e.getKeyCode() == KeyEvent.VK_KP_UP ||\r\n            e.getKeyCode() == KeyEvent.VK_W) {\r\n            System.out.println(\"Up key pressed\");\r\n            \r\n        }\r\n        if (e.getKeyCode() == KeyEvent.VK_KP_DOWN ||\r\n            e.getKeyCode() == KeyEvent.VK_S) {\r\n            System.out.println(\"Down key pressed\");\r\n            \r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void keyReleased(KeyEvent e) {\r\n        if (e.getKeyCode() == KeyEvent.VK_RIGHT ||\r\n            e.getKeyCode() == KeyEvent.VK_D) {\r\n            System.out.println(\"Right key Released\");\r\n            \r\n        }\r\n        if (e.getKeyCode() == KeyEvent.VK_LEFT ||\r\n            e.getKeyCode() == KeyEvent.VK_A) {\r\n            System.out.println(\"Left key Released\");\r\n            \r\n        }\r\n        if (e.getKeyCode() == KeyEvent.VK_KP_UP ||\r\n            e.getKeyCode() == KeyEvent.VK_W) {\r\n            System.out.println(\"Up key pressed\");\r\n            \r\n        }\r\n        if (e.getKeyCode() == KeyEvent.VK_KP_DOWN ||\r\n            e.getKeyCode() == KeyEvent.VK_S) {\r\n            System.out.println(\"Down key pressed\");\r\n            \r\n        }\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/GameLogic.java b/src/GameLogic.java
--- a/src/GameLogic.java	(revision 13cff202042c9377689eea67e2cee126cbdfce53)
+++ b/src/GameLogic.java	(date 1607834148315)
@@ -19,6 +19,7 @@
     private HashMap<Integer, Key> keyList;
     private HashMap<Integer, Player> playerList;
     private static final int MAXPLAYERS = 4;
+    private static final int trapChance = 10;
 
     
     public GameLogic(){
@@ -68,7 +69,7 @@
         {
             for(int x = 0 ; x < 9; x ++)
             {
-                if(rand.nextInt(10) <= 5 || traps >= 0){
+                if(rand.nextInt(100) <= trapChance && traps >= 0){
                     mapLayout.put(roomNumber, new Room(false, roomNumber, true, x, y));
                     traps --;
                     roomNumber ++;
@@ -173,7 +174,7 @@
         {
             for(int x = 0 ; x < 9; x ++)
             {
-                if(rand.nextInt(10) <= 5 || traps >= 0){
+                if(rand.nextInt(100) <= trapChance && traps >= 0){
                     mapLayout.put(roomNumber, new Room(false, roomNumber, true, x, y));
                     traps --;
                     roomNumber ++;
@@ -236,7 +237,7 @@
         {
             for(int x = 0 ; x < 9; x ++)
             {
-                if(rand.nextInt(10) <= 5 || traps >= 0){
+                if(rand.nextInt(100) <= trapChance && traps >= 0){
                     mapLayout.put(roomNumber, new Room(false, roomNumber, true, x, y));
                     traps --;
                     roomNumber ++;
