Index: src/MainGameController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import javafx.fxml.FXML;\r\nimport javafx.geometry.Point2D;\r\nimport javafx.scene.Group;\r\nimport javafx.scene.Node;\r\nimport javafx.scene.canvas.Canvas;\r\nimport javafx.scene.canvas.GraphicsContext;\r\nimport javafx.scene.input.MouseEvent;\r\nimport javafx.scene.layout.GridPane;\r\nimport javafx.scene.layout.VBox;\r\nimport javafx.scene.paint.Color;\r\nimport javafx.scene.shape.Rectangle;\r\n\r\nimport java.awt.*;\r\nimport java.util.*;\r\nimport javafx.scene.shape.Circle;\r\n\r\n//Edited By Svetozar Draganitchki\r\npublic class MainGameController {\r\n\r\n    //We keep track of the canvases and gridPane node refs since they're made dynamically\r\n    private Node[][] gridPaneNodes;\r\n    private Node[][] canvases;\r\n    private GameLogic gameLogic;\r\n\r\n    //References to our main window objects for easier coding/listeners yada-yada\r\n    @FXML\r\n    private VBox rootPane;\r\n\r\n    @FXML\r\n    private GridPane mainGridPane;\r\n\r\n    private Room[][]  mapLayout;\r\n    private HashMap<Integer, Key> keyList;\r\n    private HashMap<Integer, Player> playerList;\r\n    \r\n    private GameLogic GL;\r\n\r\n    private static final int PADDING = 10;\r\n\r\n    /**\r\n     * This runs first whenever application tester calls Loader.load() so it acts as the driver code for our JavaFX project\r\n     */\r\n    public void initialize() {\r\n\r\n        //We can get them number of columns/rows by checking to see how many constraints there are. There will be a specific constraint object for each row/column\r\n        int numColumns = mainGridPane.getColumnConstraints().size();\r\n        int numRows  = mainGridPane.getRowConstraints().size();\r\n\r\n        //Init arrays\r\n        gridPaneNodes = new Node[numRows][numColumns];\r\n        canvases = new Node[numRows][numColumns];\r\n        mapLayout = new Room[numRows][numColumns];\r\n        populateArray();\r\n\r\n        //We bind a listener to the size of the window to allow things to resize smoothly. resizing calls doStuff()\r\n        mainGridPane.heightProperty().addListener(evt -> doStuff());\r\n        mainGridPane.widthProperty().addListener(evt -> doStuff());\r\n\r\n        //Creates the \"map\" of rooms, players, and Keys\r\n        keyList = new HashMap<>();\r\n        playerList = new HashMap<>();\r\n        GL = new GameLogic();\r\n        mapInitializing();\r\n    }\r\n    /*\r\n    initializes the map depending on the size of the map and\r\n    number of players. By default, it generates a 9 x 9 map\r\n    and 2 players (Justin Lamberson)\r\n     */\r\n    public void mapInitializing(){\r\n        int numColumns = mainGridPane.getColumnConstraints().size();\r\n        int numRows  = mainGridPane.getRowConstraints().size();\r\n        //assumes that there are 2 players and a 9 x 9 map\r\n        Random rand = new Random();\r\n\r\n        //traps is max number of traps\r\n        int traps = 10;\r\n        int roomNumber = 1;\r\n\r\n        //loop initializes all rooms\r\n        for(int i = 0; i < numRows; i++){\r\n            for(int k = 0; k < numColumns; k++){\r\n                if(rand.nextInt(101) < 50 || traps >= 0){\r\n                    traps--;\r\n                    mapLayout[i][k] = new Room(false, roomNumber, true);\r\n\r\n                //If last room ie (8,8)\r\n                }else if(i == numRows-1 && k == numColumns-1){\r\n\r\n                    //Make special constructor for the final room so this is different from else loop\r\n                    mapLayout[i][k] = new Room(true, roomNumber, false);\r\n                } else {\r\n                    mapLayout[i][k] = new Room(false, roomNumber, false);\r\n                }\r\n                roomNumber++;\r\n            }\r\n        }\r\n        System.out.println(roomNumber);\r\n        //generates final key =\r\n        //keyList.put(81, new Key(mapLayout[8][8] ,1));\r\n\r\n        //generates the two players in the top 2 rooms\r\n        playerList.put(1, new Player(mapLayout[0][0]));\r\n        playerList.put(2, new Player(mapLayout[0][1]));\r\n\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Draw things\r\n     */\r\n    private void doStuff(){\r\n        int numColumns = mainGridPane.getColumnConstraints().size();\r\n        int numRows  = mainGridPane.getRowConstraints().size();\r\n\r\n        //First call to doStuff() will be in the initialize() method and for do to order of the loader's ops, getHeight() and getWidth() will return 0 at this point.\r\n        // So we call the prefHeight/Width in that case.\r\n        double winHeight = mainGridPane.getHeight();\r\n        double winWidth = mainGridPane.getWidth();\r\n        if(winHeight == 0 || winWidth == 0){\r\n            winHeight = mainGridPane.getPrefHeight();\r\n            winWidth = mainGridPane.getPrefWidth();\r\n        }\r\n\r\n        //Another hacky solution that I've found. getChildren().clear() removes the gridlines on our gridpane. However, this information is stored within the very first\r\n        //child so we simply store that through the deletion, and fit it back in to regain our lines.\r\n        Node node = mainGridPane.getChildren().get(0);\r\n        mainGridPane.getChildren().clear();\r\n        mainGridPane.getChildren().add(0, node);\r\n        GraphicsContext gc = null;\r\n        Canvas newMapImage = null;\r\n        Group newGroup = null;\r\n        //For each node within the gridpane draw a circle representing a room.\r\n        for(int i = 0; i < numRows; i++){\r\n            for(int k = 0; k < numColumns; k++){\r\n\r\n                //Think there's a better way to do this, but default behavior each gridpane node gets a percent of the screen X based on number of children C (size = X/C)\r\n                 newMapImage = new Canvas(winWidth/numRows, winHeight/numColumns);\r\n                canvases[i][k] = newMapImage;\r\n\r\n                //Returns a graphics object of the canvas for drawing\r\n                gc = newMapImage.getGraphicsContext2D();\r\n                Rectangle newRect = new Rectangle\r\n                        (newMapImage.getWidth()/2.0, newMapImage.getHeight()/2.0, newMapImage.getWidth()-PADDING, newMapImage.getHeight()-PADDING);\r\n                \r\n                \r\n\r\n                mapLayout[i][k].setRoomRender(newRect);\r\n                drawRectangle(gc, newRect);\r\n                \r\n                //My custom circle class from the last project we did because I wanted a quick lazy drawing to show this off.\r\n                //CircleWithText mapCircle = new CircleWithText(\"Map (\" + i + \", \" + k + \")\", new Point2D(newMapImage.getWidth()/2.0,newMapImage.getHeight()/2.0));\r\n\r\n//                //Default radius on the circles is 40, but if we start to get smaller screen sizes to where each node only has 80 pixels of room in any direction, we adjust the radius.\r\n//                if(newMapImage.getHeight() < mapCircle.getDefRadius()*2 || newMapImage.getWidth() < mapCircle.getDefRadius()*2){\r\n//\r\n//                    //We take the smaller of the two values\r\n//                    double smallerBound = Math.min(newMapImage.getHeight(), newMapImage.getWidth());\r\n//                    //double smallerBound =(newMapImage.getHeight() > newMapImage.getWidth()) ? newMapImage.getWidth(): newMapImage.getHeight();\r\n//\r\n//                    //Radius becomes half of the smallest distance to an edge.\r\n//                    mapCircle.setRadius((int)(smallerBound/2.0));\r\n//                    mapCircle.drawCusRadius(gc);\r\n//                }\r\n//\r\n//                //Otherwise we draw it normally\r\n//                else\r\n//                    mapCircle.draw(gc);\r\n                //System.out.println(\"Circle coords: \" + mapCircle.getPoint());\r\n                newGroup = new Group();\r\n                newGroup.getChildren().add(newMapImage);\r\n                mainGridPane.add(newGroup, i, k);\r\n            }\r\n        }\r\n        //Generates 4 Players.\r\n        Circle player1Graphic = new Circle\r\n                        (newMapImage.getWidth()/2.0, newMapImage.getHeight(),15);\r\n        Circle player2Graphic = new Circle\r\n                        (newMapImage.getWidth()/2.0, newMapImage.getHeight(),15);\r\n        Circle player3Graphic = new Circle\r\n                        (newMapImage.getWidth()/2.0, newMapImage.getHeight(),15);\r\n        Circle player4Graphic = new Circle\r\n                        (newMapImage.getWidth()/2.0, newMapImage.getHeight(),15);\r\n        //sets colors of 4 players\r\n        drawPlayer1(player1Graphic);\r\n        drawPlayer2(player2Graphic);\r\n        drawPlayer3(player3Graphic);\r\n        drawPlayer4(player4Graphic);\r\n        //adds 4 players to nodes the commented out code is how to add the players when we have them working.\r\n        mainGridPane.add(player1Graphic, 4, 4); //mainGridPane.add(player1Graphic, GL.getPlayer(2).getX(), GL.getPlayer(1).getY());\r\n        mainGridPane.add(player2Graphic, 0, 5); //mainGridPane.add(player2Graphic, GL.getPlayer(2).getX(), GL.getPlayer(1).getY());\r\n        mainGridPane.add(player3Graphic, 1, 2); //mainGridPane.add(player3Graphic, GL.getPlayer(2).getX(), GL.getPlayer(1).getY());\r\n        mainGridPane.add(player4Graphic, 3, 1); //mainGridPane.add(player4Graphic, GL.getPlayer(2).getX(), GL.getPlayer(1).getY());\r\n        //Groups just add an extra layer of organization. In this case not necessary, but trying to show of some of the syntax too\r\n\r\n    }\r\n\r\n    private void populateArray(){\r\n        for (Node child : mainGridPane.getChildren()) {\r\n            Integer column = GridPane.getColumnIndex(child);\r\n            Integer row = GridPane.getRowIndex(child);\r\n            if (column != null && row != null) {\r\n                gridPaneNodes[column][row] = child;\r\n            }\r\n        }\r\n        int numColumns = mainGridPane.getColumnConstraints().size();\r\n        int numRows  = mainGridPane.getRowConstraints().size();\r\n        double winHeight = mainGridPane.getHeight();\r\n        double winWidth = mainGridPane.getWidth();\r\n        if(winHeight == 0 || winWidth == 0){\r\n            winHeight = mainGridPane.getPrefHeight();\r\n            winWidth = mainGridPane.getPrefWidth();\r\n        }\r\n        for(int i = 0; i < canvases.length; i++){\r\n            for(int k = 0; k < canvases[0].length; k++){\r\n                canvases[i][k] = new Canvas(winWidth/numRows, winHeight/numColumns);\r\n            }\r\n        }\r\n    }\r\n    //Listener Wrapper, we don't care about the MouseEvent, but JavaFX requires it of its controller listener methods. Then we simply call doStuff();  -- Unused Right now\r\n    public void gridClicked(MouseEvent mouseEvent) {\r\n        doStuff();\r\n    }\r\n\r\n    private void drawRectangle(GraphicsContext gc,Rectangle rect){\r\n        gc.setFill(Color.DARKGREY);\r\n        gc.fillRect(rect.getX()-rect.getWidth()/2.0,\r\n                rect.getY()-rect.getHeight()/2.0,\r\n                rect.getWidth(),\r\n                rect.getHeight());\r\n        gc.setFill(Color.GREEN);\r\n        gc.setStroke(Color.ORANGE);\r\n    }\r\n\r\n    //TODO make players able to be visable in rooms where they are as well as deleting them from rooms\r\n\r\n\r\n    //Sets the Colors and Sizes of different players\r\n        \r\n    private void drawPlayer1(Circle Circle){\r\n        Circle.setFill(javafx.scene.paint.Color.DARKBLUE);\r\n        Circle.setTranslateX(70);\r\n        Circle.setTranslateY(20);\r\n    }\r\n    \r\n    private void drawPlayer2(Circle Circle){\r\n        Circle.setFill(javafx.scene.paint.Color.CRIMSON);\r\n        Circle.setTranslateX(70);\r\n        Circle.setTranslateY(20);\r\n    }\r\n    \r\n    private void drawPlayer3(Circle Circle){\r\n        Circle.setFill(javafx.scene.paint.Color.BLUEVIOLET);\r\n        Circle.setTranslateX(70);\r\n        Circle.setTranslateY(20);\r\n    }\r\n    \r\n    private void drawPlayer4(Circle Circle){\r\n        Circle.setFill(javafx.scene.paint.Color.CORAL);\r\n        Circle.setTranslateX(70);\r\n        Circle.setTranslateY(20);\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/MainGameController.java b/src/MainGameController.java
--- a/src/MainGameController.java	(revision 688e43b5547492d2e6307c0983c53b42362023e4)
+++ b/src/MainGameController.java	(date 1607833258736)
@@ -193,7 +193,6 @@
         mainGridPane.add(player3Graphic, 1, 2); //mainGridPane.add(player3Graphic, GL.getPlayer(2).getX(), GL.getPlayer(1).getY());
         mainGridPane.add(player4Graphic, 3, 1); //mainGridPane.add(player4Graphic, GL.getPlayer(2).getX(), GL.getPlayer(1).getY());
         //Groups just add an extra layer of organization. In this case not necessary, but trying to show of some of the syntax too
-
     }
 
     private void populateArray(){
@@ -261,4 +260,14 @@
         Circle.setTranslateX(70);
         Circle.setTranslateY(20);
     }
+
+
+    /*
+     * method to be called in order to draw the players
+     * elsewhere in the map
+     */
+    private void erasePlayer(Circle player){
+        mainGridPane.getChildren().remove(player);
+    }
+
 }
\ No newline at end of file
Index: src/Room.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import javafx.scene.shape.Rectangle;\r\n\r\nimport java.util.*;\r\n\r\n// Edited By Svetozar Draganitchki\r\npublic class Room {\r\n    private boolean isLocked;\r\n    private int doorID;\r\n    private boolean isATrap;\r\n    private Rectangle roomRender;\r\n\r\n    HashMap<Integer, Player> playersInside = new HashMap<>(); //TODO check hashmap implementation\r\n    \r\n    private Key isKey;\r\n    private int x,y;\r\n\r\n\r\n    public Room(){\r\n        this.isLocked = false;\r\n        this.doorID = -1;\r\n        this.isATrap = false;\r\n        this.isKey = null;\r\n        this.roomRender = null;\r\n    }\r\n    public Room(boolean isLocked, int doorID, boolean isATrap) {\r\n        this.isLocked = isLocked;\r\n        this.doorID = doorID;\r\n        this.isATrap = isATrap;\r\n        this.roomRender = null;\r\n    }\r\n    \r\n    //By Svetozar Draganitchki\r\n    public Room(boolean isLocked, int doorID, boolean isATrap, int x, int y) {\r\n        this.isLocked = isLocked;\r\n        this.doorID = doorID;\r\n        this.isATrap = isATrap;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.roomRender = null;\r\n    }\r\n    //By Svetozar Draganitchki\r\n    public Room(boolean isLocked, int doorID, boolean isATrap, Key isKey) {\r\n        this.isLocked = isLocked;\r\n        this.doorID = doorID;\r\n        this.isATrap = isATrap;\r\n        this.isKey = isKey;\r\n        this.roomRender = null;\r\n    }\r\n    //By Svetozar Draganitchki\r\n    public Room(boolean isLocked, int doorID, boolean isATrap, Key isKey, int x, int y) {\r\n        this.isLocked = isLocked;\r\n        this.doorID = doorID;\r\n        this.isATrap = isATrap;\r\n        this.isKey = isKey;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.roomRender = null;\r\n    }\r\n\r\n    public boolean isLocked() {\r\n        return isLocked;\r\n    }\r\n\r\n    public void setLock(boolean locked) {\r\n        isLocked = locked;\r\n    }\r\n\r\n    public int getDoorID() {\r\n        return doorID;\r\n    }\r\n\r\n    public void setDoorID(int doorID) {\r\n        this.doorID = doorID;\r\n    }\r\n\r\n    public boolean isATrap() {\r\n        return isATrap;\r\n    }\r\n\r\n    public void setATrap(boolean ATrap) {\r\n        isATrap = ATrap;\r\n    }\r\n    \r\n    public void setKey(Key a){\r\n        isKey = a;\r\n    }\r\n    \r\n    public Key getKey(){\r\n        return isKey;\r\n    }\r\n    \r\n    public int getX(){\r\n        return x;\r\n    }\r\n    \r\n    public int getY(){\r\n        return y;\r\n    }\r\n\r\n    /*TODO: Reconsider these two. We probably don't need to check for the booleans because they'll change. We can, but room.doorID should be unique from it's implementation anyway  */\r\n    @Override\r\n    public boolean equals(Object o) {\r\n        if (this == o) return true;\r\n        if (o == null || getClass() != o.getClass()) return false;\r\n        Room room = (Room) o;\r\n        return doorID == room.doorID;\r\n    }\r\n\r\n    @Override\r\n    public int hashCode() {\r\n        return Objects.hash(doorID, isATrap);\r\n    }\r\n\r\n    /*checks for a trap when a player comes into a room\r\n     *if room does have a trap, the player takes a random amount damage\r\n     * Damage taken can be no less than 1\r\n     * In addition\r\n     * Justin Lamberson\r\n     */\r\n    public void playerEntry(int playerID, Player player){\r\n        playersInside.put(playerID, player);\r\n        Random rand = new Random();\r\n        //Math.random() * (max-min+1) + min   - Will return in range\r\n        int damageTaken = rand.nextInt(5);\r\n        if(isATrap){\r\n            if(damageTaken == 0){ //check prevents the damage taken not to be less than 1\r\n                player.trapTriggered();\r\n                isATrap = false;\r\n            } else {\r\n                player.trapTriggered(damageTaken);\r\n                isATrap = false;\r\n            }\r\n        }\r\n        playersInside.put(playerID, player);\r\n    }\r\n    \r\n    /*\r\n     * method for removing a player from a room and returning that player\r\n     * -Justin Lamberson\r\n     * TODO should table be rehashed in this method? -JL\r\n     */\r\n    public Player playerExiting(int playerID){\r\n        Player player = playersInside.get(playerID);\r\n        playersInside.remove(playerID);\r\n        return player;\r\n    }\r\n\r\n    //TODO move triggered trap to room\r\n\r\n\r\n    public void setLocked(boolean locked) {\r\n        isLocked = locked;\r\n    }\r\n\r\n    public Rectangle getRoomRender() {\r\n        return roomRender;\r\n    }\r\n\r\n    public void setRoomRender(Rectangle roomRender) {\r\n        this.roomRender = roomRender;\r\n    }\r\n\r\n    public HashMap<Integer, Player> getPlayersInside() {\r\n        return playersInside;\r\n    }\r\n\r\n    public void setPlayersInside(HashMap<Integer, Player> playersInside) {\r\n        this.playersInside = playersInside;\r\n    }\r\n\r\n    /*\r\n     * a debug method in order to populate the room with both a player\r\n     * and a key\r\n     */\r\n    public void debugInitialize(){\r\n        for(int i = 1; i < 5; i++){\r\n            playersInside.put(i, new Player());\r\n        }\r\n        isKey = new Key();\r\n\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Room.java b/src/Room.java
--- a/src/Room.java	(revision 688e43b5547492d2e6307c0983c53b42362023e4)
+++ b/src/Room.java	(date 1607832293445)
@@ -124,10 +124,10 @@
         int damageTaken = rand.nextInt(5);
         if(isATrap){
             if(damageTaken == 0){ //check prevents the damage taken not to be less than 1
-                player.trapTriggered();
+                player.setHealthPool((player.getHealthPool() - 1));
                 isATrap = false;
             } else {
-                player.trapTriggered(damageTaken);
+                player.setHealthPool((player.getHealthPool() - damageTaken));
                 isATrap = false;
             }
         }
@@ -145,7 +145,7 @@
         return player;
     }
 
-    //TODO move triggered trap to room
+    // move triggered trap to room - resolved in player entry
 
 
     public void setLocked(boolean locked) {
Index: src/Player.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import java.util.ArrayList;\r\nimport java.util.HashMap;\r\n\r\n//Edited By Svetozar Draganitchki\r\npublic class Player {\r\n\r\n    private CircleWithText playerRender;\r\n    private static final int DEFAULT_HEALTH = 15;\r\n    private HashMap<String, String> playersMap; ///I think this might be useless -Svet\r\n    //What is this used for -Justin L\r\n\r\n    //TODO: Pick one of these two\r\n  //  private ArrayList<Key> keyList; \r\n    private HashMap<Integer, Key> keyList;\r\n    //private int numKeys;\r\n    private Room currentRoom;\r\n    private int healthPool;\r\n    \r\n    //variables to keep track of player location\r\n    private int x,y;\r\n    \r\n    public Player(){\r\n        healthPool = DEFAULT_HEALTH;\r\n        keyList = null;\r\n        currentRoom = null;\r\n        playersMap = new HashMap<>();\r\n    }\r\n\r\n    public Player(Room initalRoom){\r\n        healthPool = DEFAULT_HEALTH;\r\n        keyList = null;\r\n        currentRoom = null;\r\n        playersMap = new HashMap<>();\r\n    }\r\n    \r\n    //By Svetozar Draganitchki\r\n    public Player(int x,int y){\r\n        healthPool = DEFAULT_HEALTH;\r\n        keyList = null;\r\n        currentRoom = null;\r\n        playersMap = new HashMap<>();\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    public void playerDead(){\r\n        if(healthPool <= 0){\r\n            currentRoom = null;\r\n        }\r\n    }\r\n    /*\r\n     *if a trap is triggered, by default, damage taken is one\r\n     */\r\n    public void trapTriggered(){\r\n        healthPool--;\r\n    }\r\n\r\n    /*\r\n     * Overloaded method does the same thing as the default method\r\n     * but, it allows the damage taken to be set\r\n     */\r\n    public void trapTriggered(int damage){\r\n        healthPool -= damage;\r\n    }\r\n\r\n    public int getHealthPool(){\r\n        return healthPool;\r\n    }\r\n    \r\n    public Key getKey(int keyID){\r\n        return keyList.get(keyID);\r\n    }\r\n     \r\n     public void setKey(int keyID,Key key){\r\n        keyList.put(keyID,key);\r\n    } \r\n    \r\n\r\n    //By Svetozar Draganitchki\r\n    public void moveRight(){\r\n        x++;\r\n    }\r\n    \r\n    public void moveLeft(){\r\n        x--;\r\n    }\r\n    \r\n    public void moveForward(){\r\n        y++;\r\n    }\r\n    \r\n    public void moveBackward(){\r\n        y--;\r\n    }\r\n    \r\n    public int getX(){\r\n        return x;\r\n    }\r\n    public int getY(){\r\n        return y;\r\n    }\r\n}\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Player.java b/src/Player.java
--- a/src/Player.java	(revision 688e43b5547492d2e6307c0983c53b42362023e4)
+++ b/src/Player.java	(date 1607832184592)
@@ -51,21 +51,25 @@
     /*
      *if a trap is triggered, by default, damage taken is one
      */
-    public void trapTriggered(){
+    /*public void trapTriggered(){
         healthPool--;
-    }
+    }*/
 
     /*
      * Overloaded method does the same thing as the default method
      * but, it allows the damage taken to be set
      */
-    public void trapTriggered(int damage){
+    /*public void trapTriggered(int damage){
         healthPool -= damage;
-    }
+    }*/
 
     public int getHealthPool(){
         return healthPool;
     }
+
+    public void setHealthPool(int newHealth){
+        healthPool = newHealth;
+    }
     
     public Key getKey(int keyID){
         return keyList.get(keyID);
